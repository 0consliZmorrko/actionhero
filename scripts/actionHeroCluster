#!/usr/bin/env node

//////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// TO START IN CONSOLE: ./scripts/actionHeroCluster
// TO DAMEONIZE: XXX 
// 
// ** Producton-ready actionHero cluster example **
// - workers which die will be restarted
// - maser/manager specific logging
// - USR2 restarts (graceful reload of workers while handling requets)
//   -- Note, socket clients will be disconnected, but there will always be a worker to handle them
// - TTOU and TTIN signals to subtract/add workers
// - WINCH to stop all workers
// - TCP, HTTP(s), and Web-socket clients will all be shared across the cluster
// - Can be run as a daemon or in-console
//   -- you may want to explore `forever` as a dameonizing option
//
// * Setting process titles does not work on windows or OSX
// 
// This example was heavily inspired by Ruby Unicorns [[ http://unicorn.bogomips.org/ ]]
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////

// TODO: On Quit, the workers die instantly, not gracefully
// TODO: Can we pass open TCP connections to antother worker?
// TODO: Handle erronious worker crashes and restart them
// TODO: Daemonize

//////////////
// Includes //
//////////////

var fs = require('fs');
var cluster = require('cluster');
var numCPUs = require('os').cpus().length;
var colors = require('colors');

// load in the actionHero class
// normally if installed by npm: var actionHero = require("actionHero").actionHero;
var actionHero = require(__dirname + "./../api.js").actionHero; 

////////////
// config //
////////////

var config = {
	// workers: (numCPUs - 1),
	workers: 2,
	log: process.cwd() + "/log/cluster.log",
	title: "actionHero Cluster Manager",
	workerTitlePrefix: " [actionHero worker]",
	silent: true, // don't pass stdout/err to the master
};


/////////
// Log //
/////////

var logHandle = fs.createWriteStream(config.log, {flags:"a"});
var log = function(msg, col){
	
	var sqlDateTime = function(time){
		if(time == null){ time = new Date(); }
		var dateStr = 
		padDateDoubleStr(time.getFullYear()) +
		"-" + padDateDoubleStr(1 + time.getMonth()) +
		"-" + padDateDoubleStr(time.getDate()) +
		" " + padDateDoubleStr(time.getHours()) +
		":" + padDateDoubleStr(time.getMinutes()) +
		":" + padDateDoubleStr(time.getSeconds());
		return dateStr;
	};

	var padDateDoubleStr = function(i){
		return (i < 10) ? "0" + i : "" + i;
	};

	msg = sqlDateTime() + " | " + msg;
	logHandle.write(msg + "\r\n");

	if(typeof col == "string"){col = [col];}
	for(var i in col){
		msg = colors[col[i]](msg);
	}

	console.log(msg);
}

////////////////////
// Start a worker //
////////////////////

var startWorker = function(workerCounter, config, next){

	process.title = config.workerTitlePrefix + " " + workerCounter;
	workerCounter++;

	var params = {};
	var api = null;

	// any additional functions you might wish to define to be globally accessable can be added as part of params.initFunction 
	// the api object will be availalbe.
	params.initFunction = function(api, next){
		next();
	}

	// if there is no config.js file in the application's root, then actionHero will load in a collection of default params
	// you can overwrite them with params.configChanges
	params.configChanges = {
		general: {
			flatFileDirectory: "./public/"
		}
	}

  	// start the server!
  	var startServer = function(next){
  		actionHero.start(params, function(api_from_callback){
  			api = api_from_callback;
  			api.log("Boot Sucessful @ worker #" + process.pid, "green");
  			if(typeof next == "function"){
  				next(api);
  			}
  		});
  	}

  	// handle signals from master
  	process.on('message', function(msg) {
  		if(msg == "start"){
  			process.send("starting");
  			startServer(function(){
		  		process.send("started");
		  	});
  		}
  		if(msg == "stop"){
  			process.send("stopping");
			actionHero.stop(function(){
				api = null;
				process.send("stopped");
				process.exit();
			});
  		}
  		if(msg == "restart"){
  			process.send("restarting");
  			actionHero.restart(function(success, api_from_callback){
  				api = api_from_callback;
  				process.send("restarted");
  			});
  		}
  	});

  	// ignore signals passed down from master which might kill me
  	process.stdin.resume();

  	process.send("starting");
  	startServer(function(){
  		process.send("started");
  	});
}

//////////
// Main //
//////////

if (cluster.isMaster) {

	log(" - STARTING CLUSTER -", ["bold", "green"]);

	process.stdin.resume();
	process.title = config.title;
	var workerRestartArray = []; // used to trask rolling restarts of workers
	var workersExpected = 0;

	// signals
	process.on('SIGINT', function(){
		log("Signal: SIGINT");
		workersExpected = 0;
		setupShutdown();
	});
	process.on('SIGTERM', function(){
		log("Signal: SIGTERM");
		workersExpected = 0;
		setupShutdown();
	});
	process.on('SIGKILL', function(){
		log("Signal: SIGKILL");
		workersExpected = 0;
		setupShutdown();
	});
	process.on('SIGUSR2', function(){
		log("Signal: SIGUSR2");
		log("swap out new workers one-by-one");
		workerRestartArray = [];
		for(var i in cluster.workers){
			workerRestartArray.push(cluster.workers[i]);
		}
		reloadAWorker();
	});
	process.on('SIGHUP', function(){
		log("Signal: SIGHUP");
		log("reload all workers now");
		for (var i in cluster.workers){
			var worker = cluster.workers[i];
			worker.send("restart");
		}
	});
	process.on('SIGWINCH', function(){
		log("Signal: SIGWINCH");
		log("stop all workers");
		workersExpected = 0;
		for (var i in cluster.workers){
			var worker = cluster.workers[i];
			worker.send("stop");
		}
	});
	process.on('SIGTTIN', function(){
		log("Signal: SIGTTIN");
		log("add a worker");
		workersExpected++;
		startAWorker();
	});
	process.on('SIGTTOU', function(){
		log("Signal: SIGTTOU");
		log("remove a worker");
		workersExpected--;
		for (var i in cluster.workers){
			var worker = cluster.workers[i];
			worker.send("stop");
			break;
		}
	});
	process.on("exit", function(){
		workersExpected = 0;
		log("Bye!")
	});

	// signal helpers
	var startAWorker = function(){
		worker = cluster.fork();
		log("starting worker #" + worker.id);
		worker.on('message', function(message){
			if(worker.state != "none"){
				log("Message ["+worker.process.pid+"]: " + message);
			}
		});
	}

	var setupShutdown = function(){
		log("Cluster manager quitting", "red");
		log("Stopping each worker...");
		for(var i in cluster.workers){
			cluster.workers[i].send('stop');
		}
		setTimeout(loopUntilNoWorkers, 1000);
	}

	var loopUntilNoWorkers = function(){
		if(cluster.workers.length > 0){
			log("there are still " + cluster.workers.length + " workers...");
			setTimeout(loopUntilNoWorkers, 1000);
		}else{
			log("all workers gone");
			process.exit();
		}
	}

	var reloadAWorker = function(next){
		var count = 0;
		for (var i in cluster.workers){ count++; }
		if(workersExpected > count){
			startAWorker();
		}
		if(workerRestartArray.length > 0){
			var worker = workerRestartArray.pop();
			worker.send("stop");
		}
	}

	// Fork it.
	cluster.setupMaster({
		exec : __filename,
		args : process.argv.slice(2),
		silent : config.silent
	});
	for (var i = 0; i < config.workers; i++) {
		workersExpected++;
		startAWorker();
	}
	cluster.on('fork', function(worker) {
		log("worker " + worker.process.pid + " (#"+worker.id+") has spawned");
	});
	cluster.on('listening', function(worker, address) {
		
	});
	cluster.on('exit', function(worker, code, signal) {
		log("worker " + worker.process.pid + " (#"+worker.id+") has exited");
		setTimeout(reloadAWorker, 1000) // to prevent CPU-splsions if crashing too fast
	});
}else{
	var workerCounter = 0;
	startWorker(workerCounter, config);
}